# memory store, 32 words (numbered 0-31)
# words, 32 digits (numerbred 0-31, left to right)
# accumulator, 32 digits, holds the result of arithmetic operations
# CI, 32 digits, hold a single line: the adress 'line number' of instructions, is incremented before instruction, so 1st instruction to be executed is nÂ°1
# CI, during execution, CI holds a 2nd line, the PI, present instruction, the instruction being executed
# instruction: line number use digits 0,1,2,3,4 - function number use digits 13,14,15 - other digits are not used
# functions:
# 0	000	s,C	 	JMP	Copy content of Store line to CI
# 1	100	c+s,C	 	JRP	Add content of Store line to CI
# 2	010 	-s,A	 	LDN	Copy content of Store line, negated, to accumulator.
# 3 	110	a,S	 	STO	Copy content of acc. to Store line.
# 4	001	a-s, A	 	SUB	Subtract content of Store line from Accumulator
# 5	101	-		-	Same as function number 4
# 6	011	Test		CMP	Skip next instruction if content of Accumulator is negative
# 7	111	Stop		STOP	Light "Stop" neon and halt the machine.

# 5720 sec - 1h 35min 20sec
# 4598 sec - 1h 16min 38sec
# goal: 52min

class Tube
  def initialize bits
    @memory = bits.split
  end

  def read address
    # p "reading: #{address[0..4].reverse.to_i(2)} -> #{@memory[address[0..4].reverse.to_i(2)]}"
    @memory[address[0..4].reverse.to_i(2)]
  end

  def write address, value
    @memory[address[0..4].reverse.to_i(2)] = value
  end

  def display
    system 'clear'
    memory_map = @memory.each_with_index.map do |line, i|
      # "%02i: %s" % [i, line]
      line.gsub(/[01]/, '0' => '. ', '1' => '| ')
    end
    STDOUT.write memory_map.join("\n")
  end
end

class Accumulator
  def initialize
    @value = '0'*32
  end

  def write number
    result = @value.reverse.to_i(2) - number.reverse.to_i(2)
    @value = 31.downto(0).map { |n| result[n] }.join.reverse
  end

  def read
    @value
  end

  def reset
    @value = '0'*32
  end

  def test_negative?
    @value[-1] == '1'
  end
end


class SSEM
  INSTRUCTIONS = ['JMP', 'JRP', 'LDN', 'STO', 'SUB', 'SUB', 'CMP', 'STOP']

  def initialize bits
    @tube = Tube.new(bits)
    @accumulator = Accumulator.new

    @ci = '0'*32
    @stop = false
  end

  def start
    #x = 50
    begin
      @ci = ('%032b' % (@ci.reverse.to_i(2) + 0b1)).reverse
      play
      #x -= 1
      #bhjdfbhjgtv if x < 0
    end until @stop
  end

  def play
    @pi = @tube.read @ci

    #p "ci : #{@ci}"
    #p "instruction: #{INSTRUCTIONS[@pi[13..15].reverse.to_i(2)]} (arg: #{@pi[0..4].reverse.to_i(2)})"

    @tube.display

    send INSTRUCTIONS[@pi[13..15].reverse.to_i(2)]
  end

  def JMP
    @ci = @tube.read @pi
  end

  def JRP
    result = @ci.reverse.to_i(2) + @tube.read(@pi).reverse.to_i(2)
    @ci = 31.downto(0).map { |n| result[n] }.join.reverse


  #  @ci = ('%032b' % (@ci.reverse.to_i(2) + @tube.read(@pi).reverse.to_i(2))).reverse
  end

  def LDN
    @accumulator.reset
    @accumulator.write @tube.read(@pi)
  end

  def STO
    @tube.write @pi, @accumulator.read
  end

  def SUB
    @accumulator.write @tube.read(@pi)
  end

  def CMP
    if @accumulator.test_negative?
      @ci = ('%032b' % (@ci.reverse.to_i(2) + 0b1)).reverse
    end
  end

  def STOP
    @stop = true
    @tube.display
  end
end

# jump vers la ligne 3, qui stope
# 0 0
# 1 jmp 2
# 2 2
# 3 stop
SSEM.new("00000000000000000000000000000000
01000000000000000000000000000000
01000000000000000000000000000000
00000000000001110000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000").start







p "-"*32



# jump vers la ligne 3, qui jump 3 lignes plus bas, qui stope
# 0 0
# 1 jmp 2
# 2 2
# 3 jrp 3
# 4 0
# 5 0
# 6 0
# 7 stop
SSEM.new("00000000000000000000000000000000
01000000000000000000000000000000
01000000000000000000000000000000
11000000000001000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000001110000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000").start

p "-"*32

# add numbers 11 + 36 # -> 47
# memory 30 should be "11110100000000000000000000000000"
# 0 0
# 1 lnd 28
# 2 sub 29
# 3 sto 30
# 6 lnd 30
# 7 sto 30
# ...
# 28 11
# 29 36
# 30 0
SSEM.new("00000000000000000000000000000000
00111000000000100000000000000000
10111000000000010000000000000000
01111000000001100000000000000000
01111000000000100000000000000000
01111000000001100000000000000000
00000000000001110000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
11010000000000000000000000000000
00100100000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000").start

p "-"*32

# same, with numbers 49, -2 # -> 47
# memory 30 should be "11110100000000000000000000000000"
SSEM.new("00000000000000000000000000000000
00111000000000100000000000000000
10111000000000010000000000000000
01111000000001100000000000000000
01111000000000100000000000000000
01111000000001100000000000000000
00000000000001110000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
10001100000000000000000000000000
01111111111111111111111111111111
00000000000000000000000000000000
00000000000000000000000000000000").start

# try the cmp function, first put positive number, should not jump, then put negative number, should jump and stop
# 0 0
# 1 ldn 8
# 2 cmp
# 3 ldn 9
# 4 cmp
# 5 jmp 7
# 6 stop
# 7 0
# 8 -1
# 9 1
SSEM.new("00000000000000000000000000000000
00010000000000100000000000000000
00000000000000110000000000000000
10010000000000100000000000000000
00000000000000110000000000000000
11100000000000000000000000000000
00000000000001110000000000000000
00000000000000000000000000000000
11111111111111111111111111111111
10000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000").start


p "first prog"
# first program reconstruction

# 01: LDN 24   -- Accumulator := -Initial Trial Divisor
# 02: STO 26   -- Store as -Trial Divisor
# 03: LDN 26   -- Accumulator := -(-Trial Divisor)
# 04: STO 27   -- Store as +Trial Divisor
# 05: LDN 23   -- Accumulator := -(-Number)
# 06: SUB 27   -- Subtract +Trial Divisor
# 07: SKN      -- Skip if Negative
# 08: JMR 20   --   otherwise go to line 6 via indirect relative jump
# 09: SUB 26   -- Subtract -Trial Divisor to get +Remainder
# 10: STO 25   -- Store Remainder
# 11: LDN 25   -- Accumulator := -Remainder
# 12: SKN      -- Skip if Negative ; Remainder is not Zero
# 13: HLT      --   otherwise Stop ; Trial Divisor divides Number
# 14: LDN 26   -- Accumulator := -(-Trial Divisor)
# 15: SUB 21   --   and Subtract +1 to decrement Trial Divisor
# 16: STO 27   -- Store new +Trial Divisor
# 17: LDN 27   -- Accumulator := -Trial Divisor
# 18: STO 26   -- Store -Trial Divisor
# 19: JMP 22   -- Go to Line 5
# 20: NUM -3   -- jump offset
# 21: NUM 1    -- constant
# 22: NUM 4    -- jump address
# 23: NUM -35  -- negative Number
# 24: NUM 34   -- Initial Trial Divisor (typically Number-1)
# 25:          -- Remainder
# 26:          -- -Trial Divisor
# 27:          -- +Trial Divisor and Answer

x = SSEM.new("00000000000000000000000000000000
00011000000000100000000000000000
01011000000001100000000000000000
01011000000000100000000000000000
11011000000001100000000000000000
11101000000000100000000000000000
11011000000000010000000000000000
00000000000000110000000000000000
00101000000001000000000000000000
01011000000000010000000000000000
10011000000001100000000000000000
10011000000000100000000000000000
00000000000000110000000000000000
00000000000001110000000000000000
01011000000000100000000000000000
10101000000000010000000000000000
11011000000001100000000000000000
11011000000000100000000000000000
01011000000001100000000000000000
01101000000000000000000000000000
10111111111111111111111111111111
10000000000000000000000000000000
00100000000000000000000000000000
00000000000000000011111111111111
11111111111111111100000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000")

number = x.instance_variable_get("@tube").instance_variable_get("@memory")[23]
x.instance_variable_get("@tube").display
t = Time.now
x.start

z = Time.now - t
x.instance_variable_get("@tube").display
answer = x.instance_variable_get("@tube").instance_variable_get("@memory")[27]

p 'number'
p -(number.reverse.to_i(2))
p 'answer'
p answer.reverse.to_i(2)
p "tipme: #{z}"
